<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>The CRP</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/league.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>3 methods of optimizing The Critical Rendering Path</h2>
					<aside class="notes">
						It's steps how the browser convert the HTML, CSS, and JavaScript into pixels on the screen.
					</aside>
				</section>
				<section>
					<h3>The Critical Rendering Path</h3>
					<section>
						<p class="fragment">HTML --> DOM</p>
						<p class="fragment">CSS --> CSSOM</p>
						<p class="fragment">JAVASCRIPT</p>

						<aside class="notes">
							CSS parsing is blocking: the browser blocks page rendering until it receives and processes all the CSS files because some rules can be overwritten.
							<br/>
							JavaScript execution can be blocking, you can avoid it by using "defer" or "async" attribute for scripts.
						</aside>
					</section>
					<section>
						<div>
							<p>&dArr;</p>
							<p>RENDER TREE</p>
							<p>combination DOM and CSSOM with only visible content</p>
						</div>
						<div class="fragment">
							<p>&dArr;</p>
							<p>LAYOUT</p>
							<p>calculating the exact position and size of each element</p>
						</div>
						<aside class="notes">
							Render tree - The invisible tags like head or script will be ignored same as the display "none" style for elements.
							<br/>
							Layout - a browser counts the width and height of each element, and defines position on the page for all elements.
						</aside>
					</section>
					<section>
						<div>
							<p>&dArr;</p>
							<p>PAINT</p>
							<p>painting the pixels to the screen</p>
						</div>
						<div class="fragment">
							<p>&dArr;</p>
							<p>COMPOSITE</p>
							<p>division elements in multiple layers to optimization</p>
						</div>
						<aside class="notes">
							On first load, the entire screen is painted. After that, only modified areas will be repainted. So browsers are optimized to repaint by composing in particular.
						</aside>
					</section>
				</section>
				<section>
					<h3>The Critical Rendering Path</h3>
					<p>...</p>
					<p class="fragment highlight-red" data-fragment-index="3">RENDER TREE</p>
					<p>&dArr;</p>
					<p class="fragment highlight-red" data-fragment-index="2">LAYOUT</p>
					<p>&dArr;</p>
					<p class="fragment highlight-red" data-fragment-index="1">PAINT</p>
					<p>&dArr;</p>
					<p>...</p>
					<aside class="notes">
						If we change color or opacity, repaint process will be triggered.
						<br>
						If we change the screen or element size, or when we directly set or get some element property (for example, position or width), reflow will be triggered.
						<br>
						And if we add some element on the page, for example item of list, at this stage browser will modify render tree, calculate layout and paint the result on the page.
					</aside>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<img src="./images/virtualDOM.webp">
					<aside class="notes">
						The Virtual DOM is some abstraction and a lightweight copy of the real DOM. The main idea is minimizing direct manipulations of the Real DOM. If anything new has been added to the application, a new virtual DOM is created. This new Virtual DOM tree is compared with the previous Virtual DOM tree and find the changes. And only these changes update the real DOM.
					</aside>
				</section>
				<section>
					<h3>Virtual DOM</h3>
					<div style="display: flex; align-items: flex-start; justify-content: space-between">
						<div style="margin-right: 20px; flex-basis: 50%">
							<p>+</p>
							<ul>
								<li>Batch updating</li>
								<li>Lightweight updating</li>
								<li>Declarative code</li>
							</ul>
						</div>
						<div style="flex-basis: 50%">
							<p>-</p>
							<ul>
								<li>Memory usage</li>
							</ul>
						</div>
					</div>
					<aside class="notes">
						The main advantage of the Virtual DOM is applying differences to the Real DOM rather than rerendering it with each change. And the second pros for this model is manipulating Virtual DOM is fast because of it's lightweighting. But in this model we have to save the copies of Virtual DOM, so as a result memory usage increases. Maybe for simple applications, this might be more than the cost of just updating the Real DOM directly.
					</aside>
				</section>
				<section>
					<h3>SSR</h3>
					<div style="display: flex; align-items: flex-start; justify-content: space-between">
						<div style="margin-right: 20px; flex-basis: 50%">
							<p>+</p>
							<ul>
								<li>Faster page load</li>
								<li>Improved SEO</li>
								<li>Improved mobile experience</li>
								<li>Improved accessibility</li>
							</ul>
						</div>
						<div style="flex-basis: 50%">
							<p>-</p>
							<ul>
								<li>Increased server load</li>
								<li>Delayed interactivity</li>
								<li>More complex setup</li>
							</ul>
						</div>
					</div>
					<aside class="notes">
						SSR is when web pages is rendered on the server and sent to the client as a ready HTML pages. As I said before,  JavaScript is resource-heavy, SSR allows browser to load only part of JS that is needed to interact page. This means that users who visit your site will be able to see everything much faster than if they were just looking at blank screen while waiting for loading and executing JavaScript.
					</aside>
				</section>
				<section>
					<h3>Pages lazy loading</h3>
					<div style="display: flex; align-items: flex-start; justify-content: space-between">
						<div style="margin-right: 20px; flex-basis: 50%">
							<p>+</p>
							<ul>
								<li>Reduced initial load time</li>
								<li>Bandwidth conservation</li>
								<li>System resource conservation</li>
							</ul>
						</div>
						<div style="flex-basis: 50%">
							<p>-</p>
							<ul>
								<li>Increased the other pages load time</li>
							</ul>
						</div>
					</div>
					<aside class="notes">
						Lazy loading pages allows to defer the loading of non-critical resources. Instead, these non-critical resources are loaded at the moment of need. We can apply lazy loading to about any resource, not only pages. We can reduce initial load time by pages lightweighting and delivering content to users only if itâ€™s requested. And these lead to system resource conservation. But, you must understand, that there will be more time for loading another page on this site.
					</aside>
				</section>
				<section>
					<h3>Thank you!</h3>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
